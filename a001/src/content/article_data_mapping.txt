  ğ——ğ—²ğ˜€ğ—¶ğ—´ğ—» ğ˜„ğ—¶ğ˜ğ—µ ğ—£ğ—®ğ˜ğ˜ğ—²ğ—¿ğ—»ğ˜€: ğ—˜ğ—¹ğ—²ğ—´ğ—®ğ—»ğ˜ ğ——ğ—®ğ˜ğ—® ğ— ğ—®ğ—½ğ—½ğ—¶ğ—»ğ—´

  Copyright (c) 2025 Roman Vidayko
  www.linkedin.com/in/roman-vidayko

  ğ—œğ—¡ğ—§ğ—¥ğ—¢

  I decided to share my thoughts on how to make a software developer's life simpler and more efficient. It is not my intention to provide all-in-one silver bullets, but rather to offer some mindful ideas with supporting code snippets that provide fundamental understanding.

  ğ—œğ—¡ğ—–ğ—œğ—§ğ—˜

  Being developing complex software, you've probably encountered the routine of converting a data model from local data types to remote ones and vice versa. Have you ever wondered what ideal data mapping should look like?
  Here, I am going to introduce a solution that uses the power of Java and is based on the fundamental principles of Design Patterns. But let's first take a look at how it is usually done to understand the pros and cons.

  ğ—–ğ—¢ğ— ğ— ğ—¢ğ—¡ ğ—£ğ—¥ğ—”ğ—–ğ—§ğ—œğ—–ğ—˜

  Here are a couple of samples sketched out that are present in any project, like the tentacles of the Lernaean Hydraâ€”no matter how many you cut off, new ones will still grow.

  ğ—¢ğ—½ğ˜ğ—¶ğ—¼ğ—» ğŸ­: ğ——ğ—¶ğ—¿ğ—²ğ—°ğ˜ ğ—°ğ—¼ğ—»ğ˜ƒğ—²ğ—¿ğ˜€ğ—¶ğ—¼ğ—»

ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ· ğš›ğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ· = ğš—ğšğš  ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ·(
  ğš•ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ·.ğšğš’ğšğš•ğšğŸ·(),
  ...
  ğš•ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ·.ğšğš’ğšğš•ğšğ™½());

  PÍŸrÍŸoÍŸsÍŸ: ğ˜ğ˜µ ğ˜ªğ˜´ ğ˜´ğ˜ªğ˜®ğ˜±ğ˜­ğ˜¦, ğ˜¢ğ˜¯ğ˜¥ ğ˜ºğ˜°ğ˜¶ ğ˜¥ğ˜°ğ˜¯â€™ğ˜µ ğ˜³ğ˜¦ğ˜¢ğ˜­ğ˜­ğ˜º ğ˜¯ğ˜¦ğ˜¦ğ˜¥ ğ˜µğ˜° ğ˜¬ğ˜¯ğ˜°ğ˜¸ ğ˜‘ğ˜¢ğ˜·ğ˜¢ ğ˜µğ˜° ğ˜ªğ˜®ğ˜±ğ˜­ğ˜¦ğ˜®ğ˜¦ğ˜¯ğ˜µ ğ˜µğ˜©ğ˜ªğ˜´! ğŸ¥´
  CÍŸoÍŸnÍŸsÍŸ: ğ˜›ğ˜©ğ˜¦ ğ˜®ğ˜¦ğ˜µğ˜©ğ˜°ğ˜¥ ğ˜£ğ˜°ğ˜¥ğ˜º ğ˜µğ˜©ğ˜¢ğ˜µ ğ˜¤ğ˜°ğ˜¯ğ˜µğ˜¢ğ˜ªğ˜¯ğ˜´ ğ˜ªğ˜µ ğ˜ªğ˜´ ğ˜´ğ˜±ğ˜°ğ˜ªğ˜­ğ˜¦ğ˜¥ ğ˜¸ğ˜ªğ˜µğ˜© ğ˜­ğ˜°ğ˜¨ğ˜ªğ˜¤ ğ˜µğ˜©ğ˜¢ğ˜µ ğ˜ªğ˜´ ğ˜°ğ˜¶ğ˜µ ğ˜°ğ˜§ ğ˜µğ˜©ğ˜¦ ğ˜®ğ˜¦ğ˜µğ˜©ğ˜°ğ˜¥'ğ˜´ ğ˜³ğ˜¦ğ˜´ğ˜±ğ˜°ğ˜¯ğ˜´ğ˜ªğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º ğ˜´ğ˜¤ğ˜°ğ˜±ğ˜¦.

  ğ—¢ğ—½ğ˜ğ—¶ğ—¼ğ—» ğŸ®: ğ—¨ğ˜€ğ—®ğ—´ğ—² ğ—¼ğ—³ ğ— ğ—®ğ—½ğ—½ğ—²ğ—¿ ğ—¨ğ˜ğ—¶ğ—¹ğ—¶ğ˜ğ˜† ğ—–ğ—¹ğ—®ğ˜€ğ˜€

ğšğš’ğš—ğšŠğš• ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ· ğš›ğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ· = ğš‚ğšğšŠğšğš’ğšŒğ™¼ğšŠğš™ğš™ğšğš›.ğš–ğšŠğš™ğšƒğš˜ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ·(ğš•ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ·);
...
ğšŒğš•ğšŠğšœğšœ ğš‚ğšğšŠğšğš’ğšŒğ™¼ğšŠğš™ğš™ğšğš› {

  ğš™ğšğš‹ğš•ğš’ğšŒ ğšœğšğšŠğšğš’ğšŒ ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ· ğš–ğšŠğš™ğšƒğš˜ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ·(ğ™»ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ· ğš•ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ·){
    ğš›ğšğšğšğš›ğš— ğš—ğšğš  ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ·(
      ...,
      ğš–ğšŠğš™ğšƒğš˜ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ¸(ğš•ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ·));
  }

  ğš™ğšğš‹ğš•ğš’ğšŒ ğšœğšğšŠğšğš’ğšŒ ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ¸ ğš–ğšŠğš™ğšƒğš˜ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ¸(ğ™»ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ· ğš•ğš˜ğšŒğšŠğš•ğšƒğš¢ğš™ğšğŸ·){
    ğš›ğšğšğšğš›ğš— ğš—ğšğš  ğšğšğš–ğš˜ğšğšğšƒğš¢ğš™ğšğŸ¸(
      ...
  }
}

  PÍŸrÍŸoÍŸsÍŸ: ğ˜ğ˜°ğ˜µ ğ˜³ğ˜ªğ˜¥ ğ˜°ğ˜§ ğ˜µğ˜©ğ˜¦ ğ˜®ğ˜¢ğ˜±ğ˜±ğ˜ªğ˜¯ğ˜¨ ğ˜­ğ˜°ğ˜¨ğ˜ªğ˜¤ ğ˜§ğ˜ªğ˜¹ğ˜ªğ˜¯ğ˜¨ ğ˜µğ˜©ğ˜¦ ğ˜®ğ˜¦ğ˜µğ˜©ğ˜°ğ˜¥'ğ˜´ ğ˜´ğ˜ªğ˜¯ğ˜¨ğ˜­ğ˜¦ ğ˜³ğ˜¦ğ˜´ğ˜±ğ˜°ğ˜¯ğ˜´ğ˜ªğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º.
  CÍŸoÍŸnÍŸsÍŸ: ğ˜›ğ˜ªğ˜¨ğ˜©ğ˜µ ğ˜¤ğ˜°ğ˜¶ğ˜±ğ˜­ğ˜ªğ˜¯ğ˜¨ ğ˜¸ğ˜ªğ˜µğ˜© ğ˜¤ğ˜°ğ˜¯ğ˜´ğ˜¶ğ˜®ğ˜¦ğ˜³ğ˜´, ğ˜ªğ˜¯ğ˜¢ğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º ğ˜µğ˜° ğ˜¤ğ˜¶ğ˜´ğ˜µğ˜°ğ˜®ğ˜ªğ˜»ğ˜¦ ğ˜®ğ˜¦ğ˜µğ˜©ğ˜°ğ˜¥ğ˜´, ğ˜¯ğ˜¢ğ˜®ğ˜¦ğ˜´ğ˜±ğ˜¢ğ˜¤ğ˜¦ ğ˜±ğ˜°ğ˜­ğ˜­ğ˜¶ğ˜µğ˜ªğ˜°ğ˜¯, ğ˜­ğ˜°ğ˜¸ ğ˜®ğ˜¢ğ˜ªğ˜¯ğ˜µğ˜¢ğ˜ªğ˜¯ğ˜¢ğ˜£ğ˜ªğ˜­ğ˜ªğ˜µğ˜º ğ˜°ğ˜§ ğ˜¶ğ˜µğ˜ªğ˜­ğ˜ªğ˜µğ˜º ğ˜¤ğ˜­ğ˜¢ğ˜´ğ˜´ğ˜¦ğ˜´, ğ˜¢ğ˜¯ğ˜¥ ğ˜±ğ˜°ğ˜µğ˜¦ğ˜¯ğ˜µğ˜ªğ˜¢ğ˜­ ğ˜®ğ˜¦ğ˜®ğ˜°ğ˜³ğ˜º ğ˜­ğ˜¦ğ˜¢ğ˜¬ğ˜´ ğ˜¸ğ˜©ğ˜¦ğ˜¯ ğ˜µğ˜©ğ˜¦ ğ˜¯ğ˜¶ğ˜®ğ˜£ğ˜¦ğ˜³ ğ˜°ğ˜§ ğ˜´ğ˜µğ˜¢ğ˜µğ˜ªğ˜¤ ğ˜®ğ˜¦ğ˜µğ˜©ğ˜°ğ˜¥ğ˜´ ğ˜¨ğ˜³ğ˜°ğ˜¸ğ˜´ ğ˜¶ğ˜¯ğ˜¤ğ˜°ğ˜¯ğ˜µğ˜³ğ˜°ğ˜­ğ˜­ğ˜¢ğ˜£ğ˜­ğ˜º.

  ğ—¢ ğ—•ğ—¥ğ—”ğ—©ğ—˜ ğ—¡ğ—˜ğ—ª ğ—£ğ—”ğ—œğ—¡ğ—Ÿğ—˜ğ—¦ğ—¦ ğ— ğ—”ğ—£ğ—£ğ—œğ—¡ğ—š

  Thinking about this, I was looking for a solution that has a strong, clear pattern with a minimal number of checkpoints, something simple to understand and implement. It should be so clear and simple that my peers will be inclined to follow it, rather than improvising with rudimentary hacks.
  The basis of this solution involves two design patterns: ğ˜šğ˜µğ˜³ğ˜¢ğ˜µğ˜¦ğ˜¨ğ˜º and ğ˜šğ˜¦ğ˜³ğ˜·ğ˜ªğ˜¤ğ˜¦ ğ˜“ğ˜°ğ˜¤ğ˜¢ğ˜µğ˜°ğ˜³. The ğ˜šğ˜µğ˜³ğ˜¢ğ˜µğ˜¦ğ˜¨ğ˜ªğ˜¦ğ˜´ will perform the mapping, and the ğ˜šğ˜¦ğ˜³ğ˜·ğ˜ªğ˜¤ğ˜¦ ğ˜“ğ˜°ğ˜¤ğ˜¢ğ˜µğ˜°ğ˜³ will be responsible for selecting the right mappers. Additionally, the ğ˜Šğ˜°ğ˜¯ğ˜µğ˜¦ğ˜¹ğ˜µ ğ˜–ğ˜£ğ˜«ğ˜¦ğ˜¤ğ˜µ pattern is involved. This is because local and remote data sometimes only partially overlap, and the ğ˜Šğ˜°ğ˜¯ğ˜µğ˜¦ğ˜¹ğ˜µ ğ˜–ğ˜£ğ˜«ğ˜¦ğ˜¤ğ˜µ is designed to bring together all the data that needs to be contained by a target data type.
  Thatâ€™s a lot of words, letâ€™s jump into fÌ¶iÌ¶gÌ¶hÌ¶tÌ¶ coding!

  ğ—›ğ—¢ğ—ª ğ—§ğ—¢ ğ—¨ğ—¦ğ—˜

// ğ™¼ğšŠğš™ğš™ğš’ğš—ğš ğšğš˜ ğš›ğšğš–ğš˜ğšğš ğ™°ğ™¿ğ™¸ ğšğšŠğšğšŠğšğš¢ğš™ğš
ğšğš’ğš—ğšŠğš• ğšƒğš¢ğš™ğšğŸ· ğšğš¢ğš™ğšğŸ· = ğš–ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš›.ğš–ğšŠğš™(ğš—ğšğš  ğšƒğš¢ğš™ğšğŸ·ğ™²ğš˜ğš—ğšğšğš¡ğš(ğšğš¢ğš™ğšğŸ·ğ™²ğš˜ğš—ğšğšğš¡ğšğ™³ğšŠğšğšŠ));

// ğ™²ğšŠğš•ğš•ğš’ğš—ğš ğš›ğšğš–ğš˜ğšğš ğ™°ğ™¿ğ™¸
ğšğš’ğš—ğšŠğš• ğšƒğš¢ğš™ğšğŸ¸ ğšğš¢ğš™ğšğŸ¸ = ğš›ğšğš–ğš˜ğšğšğ™°ğš™ğš’ğ™°ğšğšŠğš™ğšğšğš›.ğšğšğšğšğšğš–ğš˜ğšğšğ™³ğšŠğšğšŠ(ğšğš¢ğš™ğšğŸ·);

// ğ™¼ğšŠğš™ğš™ğš’ğš—ğš ğšğš˜ ğš•ğš˜ğšŒğšŠğš• ğšğšŠğšğšŠğšğš¢ğš™ğš ğšğš›ğš˜ğš– ğš›ğšğš–ğš˜ğšğš ğ™°ğ™¿ğ™¸ ğšğšŠğšğšŠğšğš¢ğš™ğš
ğšƒğš¢ğš™ğšğŸ¹ ğšğš¢ğš™ğšğŸ¹ = ğš–ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš›.ğš–ğšŠğš™(ğš—ğšğš  ğšƒğš¢ğš™ğšğŸ¹ğ™²ğš˜ğš—ğšğšğš¡ğš(ğšğš¢ğš™ğšğŸ¸));

  How do you like the way the new mapping looks? Easy-peasy? Just calling the mapperLocator's single method, and that's it!
  Letâ€™s go under the hood and see if the technical side of the solution is just as wonderful?

  ğ—¦ğ—œğ—¥ ğ— ğ—”ğ—£ğ—£ğ—˜ğ—¥-ğ—Ÿğ—¢ğ—–ğ—”ğ—§ğ—¢ğ—¥

ğš™ğšğš‹ğš•ğš’ğšŒ ğšŒğš•ğšŠğšœğšœ ğ™¼ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš› {
  ğš™ğš›ğš’ğšŸğšŠğšğš ğšğš’ğš—ğšŠğš• ğ™¼ğšŠğš™<ğ™²ğš•ğšŠğšœğšœ<ğš‚ğš˜ğšğš›ğšŒğš>, ğ™¼ğšŠğš™ğš™ğšğš›<? ğšğš¡ğšğšğš—ğšğšœ ğš‚ğš˜ğšğš›ğšŒğš, ?>> ğš–ğšŠğš™ğš™ğšğš›ğšœ = ğš—ğšğš  ğ™·ğšŠğšœğš‘ğ™¼ğšŠğš™<>();

  ğš™ğšğš‹ğš•ğš’ğšŒ ğ™¼ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš›(ğ™»ğš’ğšœğš<ğ™¼ğšŠğš™ğš™ğšğš›<? ğšğš¡ğšğšğš—ğšğšœ ğš‚ğš˜ğšğš›ğšŒğš, ?>> ğš–ğšŠğš™ğš™ğšğš›ğšœ) {
    ğš–ğšŠğš™ğš™ğšğš›ğšœ.ğšœğšğš›ğšğšŠğš–().ğšğš˜ğš›ğ™´ğšŠğšŒğš‘(ğšğš‘ğš’ğšœ::ğš›ğšğšğš’ğšœğšğšğš›);
  }

  ğš™ğš›ğš’ğšŸğšŠğšğš ğšŸğš˜ğš’ğš ğš›ğšğšğš’ğšœğšğšğš›(ğ™¼ğšŠğš™ğš™ğšğš›<? ğšğš¡ğšğšğš—ğšğšœ ğš‚ğš˜ğšğš›ğšŒğš, ?> ğš–ğšŠğš™ğš™ğšğš›){
    ğš–ğšŠğš™ğš™ğšğš›ğšœ.ğš™ğšğš(ğšğšğšğš‚ğš˜ğšğš›ğšŒğšğšƒğš¢ğš™ğš(ğš–ğšŠğš™ğš™ğšğš›), ğš–ğšŠğš™ğš™ğšğš›);
  }

  ğš™ğšğš‹ğš•ğš’ğšŒ <ğšƒ> ğšƒ ğš–ğšŠğš™(ğš‚ğš˜ğšğš›ğšŒğš ğšœğš˜ğšğš›ğšŒğš) {
    ğš›ğšğšğšğš›ğš— ((ğ™¼ğšŠğš™ğš™ğšğš›<ğš‚ğš˜ğšğš›ğšŒğš, ğšƒ>) ğš–ğšŠğš™ğš™ğšğš›ğšœ.ğšğšğš(ğšœğš˜ğšğš›ğšŒğš.ğšğšğšğ™²ğš•ğšŠğšœğšœ())).ğš–ğšŠğš™(ğšœğš˜ğšğš›ğšŒğš);
  }

  ğš™ğš›ğš’ğšŸğšŠğšğš ğ™²ğš•ğšŠğšœğšœ<ğš‚ğš˜ğšğš›ğšŒğš> ğšğšğšğš‚ğš˜ğšğš›ğšŒğšğšƒğš¢ğš™ğš(ğ™¼ğšŠğš™ğš™ğšğš›<? ğšğš¡ğšğšğš—ğšğšœ ğš‚ğš˜ğšğš›ğšŒğš, ?> ğš–ğšŠğš™ğš™ğšğš›) {
    // ğš‚ğš˜ğš–ğš ğ™¹ğšŠğšŸğšŠ ğšğšğšğš•ğšğšŒğšğš’ğš˜ğš— ğšŒğš˜ğšğš ğš ğš‘ğšŠğš ğš’ğšğšğš—ğšğš’ğšğš’ğšğšœ ğšğš‘ğš ğšœğš˜ğšğš›ğšŒğš ğšğšŠğšğšŠ-ğšğš¢ğš™ğš ğšğš˜ğš› ğšŠ ğš–ğšŠğš™ğš™ğšğš›
  }
}

  No magic, just an ordinary job. The source types are keys to identify the right mapper. Source is just a marker interface. Simply supply the mapper instances to the constructor, or declare them as beans if it's a Spring application.

  ğ—§ğ—›ğ—˜ ğ— ğ—œğ—¡ğ—œğ—¢ğ—¡ğ—¦

ğš™ğšğš‹ğš•ğš’ğšŒ ğš’ğš—ğšğšğš›ğšğšŠğšŒğš ğ™¼ğšŠğš™ğš™ğšğš›<ğš‚ğš˜ğšğš›ğšŒğš, ğšƒ> {
  ğšƒ ğš–ğšŠğš™(ğš‚ğš˜ğšğš›ğšŒğš ğšœğš˜ğšğš›ğšŒğš);
}

ğš™ğšğš‹ğš•ğš’ğšŒ ğšŒğš•ğšŠğšœğšœ ğšƒğš¢ğš™ğšğŸ¸ğ™¼ğšŠğš™ğš™ğšğš› ğš’ğš–ğš™ğš•ğšğš–ğšğš—ğšğšœ ğ™¼ğšŠğš™ğš™ğšğš›<ğšƒğš¢ğš™ğšğŸ¸ğ™²ğš˜ğš—ğšğšğš¡ğš, ğšƒğš¢ğš™ğšğŸ¸> {
  @ğ™¾ğšŸğšğš›ğš›ğš’ğšğš
  ğš™ğšğš‹ğš•ğš’ğšŒ ğšƒğš¢ğš™ğšğŸ¸ ğš–ğšŠğš™(ğšƒğš¢ğš™ğšğŸ¸ğ™²ğš˜ğš—ğšğšğš¡ğš ğšœğš˜ğšğš›ğšŒğš) {
    ğš›ğšğšğšğš›ğš— ğš—ğšğš  ğšƒğš¢ğš™ğšğŸ¸(ğšœğš˜ğšğš›ğšŒğš.ğšğš’ğšğš•ğšğŸ·, ... , ğšœğš˜ğšğš›ğšŒğš.ğšğš’ğšğš•ğšğ™½);
  }
}

ğš™ğšğš‹ğš•ğš’ğšŒ ğšŒğš•ğšŠğšœğšœ ğšƒğš¢ğš™ğšğŸ·ğ™¼ğšŠğš™ğš™ğšğš› ğš’ğš–ğš™ğš•ğšğš–ğšğš—ğšğšœ ğ™¼ğšŠğš™ğš™ğšğš›<ğšƒğš¢ğš™ğšğŸ·ğ™²ğš˜ğš—ğšğšğš¡ğš, ğšƒğš¢ğš™ğšğŸ·> {
  @ğ™°ğšğšğš˜ğš ğš’ğš›ğšğš @ğ™»ğšŠğš£ğš¢
  ğš™ğš›ğš’ğšŸğšŠğšğš ğ™¼ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš› ğš–ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš›;

  @ğ™¾ğšŸğšğš›ğš›ğš’ğšğš
  ğš™ğšğš‹ğš•ğš’ğšŒ ğšƒğš¢ğš™ğšğŸ· ğš–ğšŠğš™(ğšƒğš¢ğš™ğšğŸ·ğ™²ğš˜ğš—ğšğšğš¡ğš ğšœğš˜ğšğš›ğšŒğš) {
    ğšğš’ğš—ğšŠğš• ğšƒğš¢ğš™ğšğŸ¸ ğšğš¢ğš™ğšğŸ¸ = ğš–ğšŠğš™ğš™ğšğš›ğ™»ğš˜ğšŒğšŠğšğš˜ğš›.ğš–ğšŠğš™(ğš—ğšğš  ğšƒğš¢ğš™ğšğŸ¸ğ™²ğš˜ğš—ğšğšğš¡ğš(ğšœğš˜ğšğš›ğšŒğš.ğšğš’ğšğš•ğšğš‡, ğšğš’ğšğš•ğšğšˆ));
    ğš›ğšğšğšğš›ğš— ğš—ğšğš  ğšƒğš¢ğš™ğšğŸ·(ğšœğš˜ğšğš›ğšŒğš.ğšğš’ğšğš•ğšğŸ·, ... , ğšœğš˜ğšğš›ğšŒğš.ğšğš’ğšğš•ğšğ™½, ğšğš¢ğš™ğšğŸ¸);
  }
}

  This is the last thing needed to implement. Mappers are just mappers, well distinguished by the MapperLocator. By the way, they allow you to call the MapperLocator from inside for doing nested mapping.

  ğ—£ğ—¥ğ—¢ğ—¦

  Simple to use, easy to increase mapping coverage, loose coupling, atomicity of mappers, easy testing and maintenance, and regular JVM garbage collection is efficient.

  ğ—–ğ—¢ğ—¡ğ—¦

  The entry-level requirements for developers are higher, requiring code reviews and proper test coverage.

  ğ—¦ğ—¨ğ— ğ— ğ—”ğ—¥ğ—¬

  What is the way to use this solution once itâ€™s introduced? Simply add a ğ˜•ğ˜¦ğ˜¸ğ˜›ğ˜ºğ˜±ğ˜¦ğ˜”ğ˜¢ğ˜±ğ˜±ğ˜¦ğ˜³, a ğ˜•ğ˜¦ğ˜¸ğ˜›ğ˜ºğ˜±ğ˜¦ğ˜Šğ˜°ğ˜¯ğ˜µğ˜¦ğ˜¹ğ˜µ, and supply the new mapper to the ğ˜”ğ˜¢ğ˜±ğ˜±ğ˜¦ğ˜³ğ˜“ğ˜°ğ˜¤ğ˜¢ğ˜µğ˜°ğ˜³. Then call the new mapper via the mapperLocator's ğ˜®ğ˜¢ğ˜±() method.

  ğ˜–ğ˜³ğ˜ªğ˜¨ğ˜ªğ˜¯ğ˜¢ğ˜­ ğ˜¢ğ˜³ğ˜µğ˜ªğ˜¤ğ˜­ğ˜¦: https://github.com/roman-vidayko/articles/blob/main/a001/src/content/article_data_mapping.txt

  ğ˜šğ˜µğ˜¢ğ˜³ğ˜µğ˜ªğ˜¯ğ˜¨ ğ˜±ğ˜°ğ˜ªğ˜¯ğ˜µ ğ˜µğ˜° ğ˜­ğ˜¦ğ˜¢ğ˜³ğ˜¯ ğ˜µğ˜©ğ˜¦ ğ˜¤ğ˜°ğ˜¥ğ˜¦: https://github.com/roman-vidayko/articles/blob/main/a001/src/main/java/com/vidayko/service/CustomerApiService.java#L38-L53

  Copyright (c) 2025 Roman Vidayko